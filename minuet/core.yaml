# PACKAGE COLLECTION: MINUET CORE
# SUPPORTED HARDWARE: Minuet v3.0 and v3.1.
#
# Configures the hardware and implements core features.
#
# Required variables:
#   - Set `minuet_board_version` according to the silkscreen label on your
#     Minuet circuit board, e.g. "v3_0".
#
# Optional variables:
#   - Set `minuet_indoor_ambient_temperature_sensor_id` to provide the
#     indoor ambient temperature in Celsius.
#     Defaults to "minuet_ambient_temperature" for the built-in thermistor.
#   - Set `minuet_indoor_relative_humidity_sensor_id` to provide the
#     indoor relative humidity in percent.
#     Defaults to "" for none.
#   - Set `minuet_indoor_co2_sensor_id` to provide the
#     indoor carbon dioxide concentration in ppm.
#     Defaults to "" for none.
#   - Set `minuet_indoor_aqi_sensor_id` to provide the
#     indoor air quality index.
#     Defaults to "" for none.
#   - Set `minuet_outdoor_ambient_temperature_sensor_id` to provide the
#     outdoor ambient temperature in Celsius.
#     Defaults to "" for none.
#   - Set `minuet_outdoor_relative_humidity_sensor_id` to provide the
#     outdoor relative humidity in percent.
#     Defaults to "" for none.
#   - Set `minuet_outdoor_aqi_sensor_id` to provide the
#     outdoor air quality index.
#     Defaults to "" for none.
defaults:
  minuet_board_version: "unknown"
  minuet_indoor_ambient_temperature_sensor_id: "minuet_ambient_temperature"
  minuet_indoor_relative_humidity_sensor_id: ""
  minuet_indoor_co2_sensor_id: ""
  minuet_indoor_aqi_sensor_id: ""
  minuet_outdoor_ambient_temperature_sensor_id: ""
  minuet_outdoor_relative_humidity_sensor_id: ""
  minuet_outdoor_aqi_sensor_id: ""

### PACKAGE: PROJECT
#
# Provides project information for adopting the Minuet firmware configuration
# into the ESPHome Builder.  Dashboard import is not enabled because ESPHome does
# not currently pull in all of the files needed to build the firmware that way.
minuet_project:
  esphome:
    project:
      name: "brown-studios.minuet"
      version: "3.0.2"
  #dashboard_import:
  #  package_import_url: "github://brown-studios/minuet-firmware/minuet.yaml@main"
  #  import_full_config: true

### PACKAGE: BUILD
#
# Build options for ESPHome.
minuet_build:
  esphome:
    min_version: "2025.11.5"
    includes:
      - minuet/core.h
      - minuet/fan_driver.h
      - minuet/governor.h
    platformio_options:
      build_flags: >
        -Wno-packed-bitfield-compat
        -DCONFIG_ADC_SUPPRESS_DEPRECATE_WARN=1
  external_components:
    - source: github://brown-studios/esphome-maxxfan-protocol@main
      components: [ maxxfan_protocol ]
      refresh: 1min
    - source: github://brown-studios/esphome-mcf8316@main
      components: [ mcf8316 ]
      refresh: 1min

### PACKAGE: BOARD
#
# Specifies the microcontroller family, pins, and I/O busses.
minuet_board:
  # ESP32-C3
  esp32:
    board: esp32-c3-devkitm-1
    framework:
      type: esp-idf

  # Define hardware version dependent substitutions
  substitutions:
    # I2C pins
    minuet_pin_scl: 8
    minuet_pin_sda_:
      v3_0: 7
      v3_1: 6
    minuet_pin_sda: ${minuet_pin_sda_[minuet_board_version]}
    # Accessory pins: acc0 and acc1 have ADC function, acc2 and acc3 are digital only
    minuet_pin_acc0: 0
    minuet_pin_acc1: 1
    minuet_pin_acc2: 5
    minuet_pin_acc3_:
      v3_0: 6
      v3_1: 7
    minuet_pin_acc3: ${minuet_pin_acc3_[minuet_board_version]}

  # The I2C bus is used by built-in components and is presented via a
  # QWIIC connector on the board edge for accessories
  i2c:
    - id: minuet_i2c
      scl:
        number: ${minuet_pin_scl}
        ignore_strapping_warning: true
      sda:
        number: ${minuet_pin_sda}
      scan: true
      frequency: 100kHz

  # The built-in TCA9555 provides additional 16 GPIO pins, all of which are
  # used by built-in functions. If you need more GPIO pins, you can attach another
  # GPIO expander via the QWIIC port, taking care to assign it an unused I2C address.
  pca9554:
    - id: minuet_xio
      i2c_id: minuet_i2c
      address: 0x20
      pin_count: 16

### PACKAGE: FAN DRIVER
#
# Interfaces with the fan motor MCF8316 driver chip.
# See also fan_driver.h.
# TODO:
# - Add a select entity to pick a motor descriptor
minuet_fan_driver:
  mcf8316:
    - id: minuet_fan_driver
      address: 0x01
      wake:
        pca9554: minuet_xio
        number: 13
        mode: output
      nfault:
        pca9554: minuet_xio
        number: 12
        mode: input
      watchdog: true
      on_fault:
        then:
          - lambda: |-
              // TODO: Consider handling OTW (over-temperature warning) fault by reducing the fan speed
              id(minuet_fan_driver_fault_recovery).execute(x.is_faulted());

              std::string fault_text;
              if (x.gate_driver) {
                fault_text = esphome::mcf8316::format_gate_driver_fault_status(x.gate_driver);
              }
              if (x.controller) {
                if (!fault_text.empty()) fault_text.append(" ");
                fault_text.append(esphome::mcf8316::format_controller_fault_status(x.controller));
              }
              if (fault_text.empty()) fault_text = "OK";
              if (id(minuet_fan_driver_fault_text).state != fault_text) {
                id(minuet_fan_driver_fault_text).publish_state(fault_text);
              }
  sensor:
    - id: minuet_fan_tach
      name: "Fan tachometer"
      icon: mdi:fan
      state_class: measurement
      entity_category: diagnostic
      unit_of_measurement: rpm
      accuracy_decimals: 0
      platform: template
      update_interval: 5s
      filters:
        - delta: 5
        - round_to_multiple_of: 10
      lambda: 'return minuet::fan_driver::controller.get_tachometer_rpm();'
    - id: minuet_fan_driver_bus_current
      name: "Fan driver bus current"
      state_class: measurement
      device_class: current
      entity_category: diagnostic
      unit_of_measurement: A
      accuracy_decimals: 2
      disabled_by_default: true
      platform: template
      update_interval: never
      filters:
        - delta: 0.005
        - round_to_multiple_of: 0.01
      lambda: 'return minuet::fan_driver::controller.get_bus_current();'
    - id: minuet_fan_driver_motor_phase_peak_current
      name: "Fan driver motor phase peak current"
      state_class: measurement
      device_class: current
      entity_category: diagnostic
      unit_of_measurement: A
      accuracy_decimals: 2
      disabled_by_default: true
      platform: template
      update_interval: never
      filters:
        - delta: 0.005
        - round_to_multiple_of: 0.01
      lambda: 'return minuet::fan_driver::controller.get_motor_phase_peak_current();'
    - id: minuet_fan_driver_vm_voltage
      name: "Fan driver VM voltage"
      state_class: measurement
      device_class: voltage
      entity_category: diagnostic
      unit_of_measurement: V
      accuracy_decimals: 2
      disabled_by_default: true
      platform: template
      update_interval: never
      filters:
        - delta: 0.005
        - round_to_multiple_of: 0.01
      lambda: 'return minuet::fan_driver::controller.get_vm_voltage();'
  text_sensor:
    - id: minuet_fan_driver_fault_text
      name: "Fan driver fault status"
      icon: mdi:fan-alert
      entity_category: diagnostic
      disabled_by_default: true
      platform: template
      update_interval: never
  switch:
    - id: minuet_fan_driver_diagnostics
      name: "Fan driver diagnostics"
      icon: mdi:bug-outline
      platform: template
      restore_mode: DISABLED
      optimistic: true
      entity_category: diagnostic
      disabled_by_default: true
  button:
    - id: minuet_fan_driver_mpet
      name: "Start motor parameter extraction tool"
      icon: mdi:gear
      platform: template
      disabled_by_default: true
      entity_category: config
      on_press:
        then:
          - lambda: |-
              minuet::fan_driver::controller.start_mpet();
  esphome:
    on_boot:
      - priority: 750 # between HARDWARE (mcf8316 component and DATA (template fan component)
        then:
          - lambda: |-
              // TODO: allow the motor to be configured
              id(minuet_fan_driver_fault_text).publish_state("OK");
              minuet::fan_driver::controller.init(minuet::fan_driver::MOTORS[0]);
  interval:
    - interval: 1s
      then:
        lambda: |-
          if (id(minuet_fan_driver_diagnostics).state) {
            id(minuet_fan_driver_bus_current).update();
            id(minuet_fan_driver_motor_phase_peak_current).update();
            id(minuet_fan_driver_vm_voltage).update();
          }
  script:
    - id: minuet_fan_driver_fault_recovery
      mode: restart
      parameters:
        faulted: bool
      then:
        - if:
            condition:
              - lambda: 'return faulted;'
            then:
              - delay: 2s # Allow time for the fault to resolve itself if it's transient or there's an automtic retry configured
              - logger.log: "Stopped the fan due to a persistent fault"
              - script.execute:
                  id: minuet_tone
                  name: "!fan_driver_fault"
              - fan.turn_off: minuet_fan

### PACKAGE: LID MOTOR DRIVER
#
# Interfaces with the lid motor DRV8876 driver chip.
minuet_lid_motor_driver:
  binary_sensor:
    - id: minuet_lid_motor_fault
      platform: gpio
      pin:
        pca9554: minuet_xio
        number: 9
        mode: input
        inverted: true
      trigger_on_initial_state: true
      use_interrupt: false
  output:
    - id: minuet_lid_motor_sleep
      platform: gpio
      pin:
        pca9554: minuet_xio
        number: 10
        mode: output
        inverted: true
    - id: minuet_lid_motor_open
      platform: gpio
      pin:
        pca9554: minuet_xio
        number: 11
        mode: output
        inverted: false

### PACKAGE: AMBIENT TEMPERATURE SENSOR
#
# Reads the on-board thermistor.
minuet_ambient_temperature_sensor:
  sensor:
    - id: minuet_thermistor_voltage
      platform: adc
      pin: 4
      attenuation: 12db
      filters:
        - sliding_window_moving_average:
            window_size: 20
            send_every: 10
            send_first_at: 10
        - delta: 0.005
      update_interval: never
    - id: minuet_thermistor_resistance
      platform: resistance
      sensor: minuet_thermistor_voltage
      configuration: DOWNSTREAM
      resistor: 10kOhm
    - id: minuet_ambient_temperature
      name: "Ambient temperature"
      platform: ntc
      sensor: minuet_thermistor_resistance
      calibration:
        b_constant: 3950
        reference_temperature: 25Â°C
        reference_resistance: 10kOhm
      accuracy_decimals: 1
      filters:
        - delta: 0.1
        - round_to_multiple_of: 0.2
  output:
    - id: minuet_thermistor_power
      platform: gpio
      pin:
        pca9554: minuet_xio
        number: 14
        mode: output
        inverted: false
  interval:
    - interval: 0.5s
      then:
        lambda: |-
          id(minuet_thermistor_power).turn_on();
          id(minuet_thermistor_voltage).update();
          id(minuet_thermistor_power).turn_off();

### PACKAGE: BATTERY MONITOR
#
# Reads the supply voltage and compares it to configurable voltage thresholds.
# Implements the battery safety lock.
minuet_battery_monitor:
  binary_sensor:
    - id: minuet_battery_safety_lock
      name: "Battery safety lock"
      icon: mdi:lock
      entity_category: diagnostic
      platform: template
      trigger_on_initial_state: true
      on_state:
        then:
          - script.execute: minuet_safety_lock_update
  sensor:
    - id: minuet_battery_voltage
      name: "Battery voltage"
      icon: mdi:car-battery
      device_class: voltage
      state_class: measurement
      entity_category: diagnostic
      unit_of_measurement: V
      accuracy_decimals: 1
      platform: adc
      pin: 3
      attenuation: 12db
      filters:
        - sliding_window_moving_average:
            window_size: 10
            send_every: 5
            send_first_at: 5
        - multiply: 11
        - delta: 0.1
        - round_to_multiple_of: 0.2
      update_interval: 0.5s
      on_value:
        then:
          - lambda: |-
              auto& lock = id(minuet_battery_safety_lock);
              const float hysteresis = lock->state ? 0.4f : 0.f;
              const bool low = x < id(minuet_battery_voltage_low).state + hysteresis;
              const bool high = x > id(minuet_battery_voltage_high).state - hysteresis;
              lock->publish_state(low || high);
  number:
    - id: minuet_battery_voltage_low
      name: "Low battery voltage threshold"
      icon: mdi:battery-alert
      entity_category: config
      device_class: voltage
      unit_of_measurement: V
      mode: box
      platform: template
      optimistic: true
      min_value: 9
      max_value: 16
      step: 0.2
      restore_value: true
      initial_value: 10.8
    - id: minuet_battery_voltage_high
      name: "High battery voltage threshold"
      icon: mdi:battery-alert
      entity_category: config
      device_class: voltage
      unit_of_measurement: V
      mode: box
      platform: template
      optimistic: true
      min_value: 9
      max_value: 16
      step: 0.2
      restore_value: true
      initial_value: 15.2

### PACKAGE: RAIN SENSOR
#
# Reads and latches the rain sensor state.
# Implements the rain safety lock.
minuet_rain_sensor:
  binary_sensor:
    - id: minuet_rain
      name: "Rain sensor"
      icon: mdi:weather-rainy
      device_class: moisture
      entity_category: diagnostic
      platform: gpio
      pin:
        pca9554: minuet_xio
        number: 8
        mode: input
        inverted: true
      use_interrupt: false
      trigger_on_initial_state: true
      filters:
        - delayed_on_off:
            time_on: 2s
            time_off: 30s
      on_state:
        then:
          - script.execute: minuet_rain_sensor_update
    - id: minuet_rain_stopped_fan
      name: "Rain stopped fan"
      device_class: problem
      entity_category: diagnostic
      platform: template
      trigger_on_initial_state: true
    - id: minuet_rain_safety_lock
      name: "Rain safety lock"
      icon: mdi:lock
      entity_category: diagnostic
      platform: template
      trigger_on_initial_state: true
      on_state:
        then:
          - script.execute: minuet_safety_lock_update
  switch:
    - id: minuet_rain_sensor_enabled
      name: "Rain sensor enabled"
      icon: mdi:weather-rainy
      platform: template
      optimistic: true
      restore_mode: RESTORE_DEFAULT_ON
      on_state:
        then:
          - lambda: |-
              if (!id(minuet_rain_sensor_enabled).state) {
                id(minuet_rain_stopped_fan).publish_state(false);
              }
              id(minuet_rain_sensor_update).execute();
  button:
    - id: minuet_rain_sensor_reset
      name: "Reset rain sensor"
      icon: mdi:weather-rainy
      platform: template
      on_press:
        then:
          - lambda: |-
              id(minuet_rain_stopped_fan).publish_state(false);
              if (!id(minuet_rain_sensor_enabled).state) {
                id(minuet_rain_sensor_enabled).turn_on();
              } else {
                id(minuet_rain_sensor_update).execute();
              }
  script:
    - id: minuet_rain_sensor_update
      mode: queued
      then:
        - lambda: |-
            const bool rain = id(minuet_rain).state;
            const bool rain_stopped_fan = id(minuet_rain_stopped_fan).state;
            const bool rain_sensor_enabled = id(minuet_rain_sensor_enabled).state;
            const auto& fan = id(minuet_fan);
            const auto& lid = id(minuet_lid);
            if (!rain_stopped_fan && rain_sensor_enabled && rain && (fan->state || minuet::cover_is_open_or_opening(lid))) {
              ESP_LOGI(minuet::TAG, "Rain sensor detected rain and activated the safety lock to stop the fan");
              id(minuet_rain_stopped_fan).publish_state(true);
            }
            id(minuet_rain_safety_lock).publish_state(rain_sensor_enabled && (rain || rain_stopped_fan));
    - id: minuet_rain_safety_lock_maybe_triggered
      mode: queued
      then:
        - lambda: |-
            // A fan or lid operation was aborted due to a safety lock, check whether the rain safety lock
            // contributed to the situation and set rain stopped fan to make the rain indicator flash.
            if (id(minuet_rain_safety_lock).state) {
              id(minuet_rain_stopped_fan).publish_state(true);
            }

### PACKAGE: SAFETY LOCK
#
# Aggregates the individual safety lock reasons.
# Stops the fan and closes the lid when a safety lock is triggered.
# Inhibits fan and lid operation until all safety lock are released.
minuet_safety_lock:
  binary_sensor:
    - id: minuet_accessory_safety_lock
      name: "Accessory safety lock"
      icon: mdi:lock
      entity_category: diagnostic
      platform: gpio
      pin:
        pca9554: minuet_xio
        number: 15
        mode: input
        inverted: true
      use_interrupt: false
      trigger_on_initial_state: true
      filters:
        - delayed_on_off: 250ms
      on_state:
        then:
          - script.execute: minuet_safety_lock_update
    - id: minuet_safety_lock
      name: "Safety lock"
      icon: mdi:lock
      entity_category: diagnostic
      platform: template
  text_sensor:
    - id: minuet_safety_lock_reason
      name: "Safety lock reason"
      icon: mdi:lock
      entity_category: diagnostic
      platform: template
      update_interval: never
  switch:
    - id: minuet_manual_safety_lock
      name: "Manual safety lock"
      icon: mdi:lock
      platform: template
      optimistic: true
      restore_mode: RESTORE_DEFAULT_OFF
      on_state:
        then:
          - script.execute: minuet_safety_lock_update
    - id: minuet_automation_safety_lock
      name: "Automation safety lock"
      icon: mdi:lock
      platform: template
      optimistic: true
      restore_mode: RESTORE_DEFAULT_OFF
      on_state:
        then:
          - script.execute: minuet_safety_lock_update
  script:
    - id: minuet_safety_lock_update
      mode: queued
      then:
        - lambda: |-
            bool locked;
            const char* reason;
            if (id(minuet_battery_safety_lock).state) {
              locked = true;
              reason = "Battery";
            } else if (id(minuet_rain_safety_lock).state) {
              locked = true;
              reason = "Rain";
            } else if (id(minuet_accessory_safety_lock).state) {
              locked = true;
              reason = "Accessory";
            } else if (id(minuet_manual_safety_lock).state) {
              locked = true;
              reason = "Manual";
            } else if (id(minuet_automation_safety_lock).state) {
              locked = true;
              reason = "Automation";
            } else {
              locked = false;
              reason = "None";
            }
            id(minuet_safety_lock).publish_state(locked);
            if (id(minuet_safety_lock_reason).state != reason) {
              id(minuet_safety_lock_reason).publish_state(reason);
            }

            // Turn the fan off and close the lid when the safety lock is engaged.
            const auto& fan = id(minuet_fan);
            const auto& lid = id(minuet_lid);
            if (locked && (fan->state || minuet::cover_is_open_or_opening(lid))) {
              ESP_LOGI(minuet::TAG, "Safety lock stopped the fan and closed the lid: %s safety lock active", reason);
              minuet::perform_transient_operation([=] {
                if (fan->state) {
                  fan->make_call().set_state(false).perform();
                }
                if (minuet::cover_is_open_or_opening(lid)) {
                  lid->make_call().set_command_close().perform();
                }
              });
            }

            // How much of the fan's state should be preserved when entering a safety lock state and restored when
            // exiting that state afterwards?  The fan could certainly return to the same state it had been in just
            // prior to the safety lock being engaged but that state may no longer be appropriate as circumstances
            // may have changed in the meantime.  The user might be surprised when the fan turns itself on again
            // spontanelously many hours later and many miles down the road.
            //
            // This routine keeps the fan off upon exiting the locked state unless the user has left the automatic
            // themostat enabled, in which case it restores control to the thermostat.  The safety lock also
            // resets and suppresses the thermostat override.
            if (locked) {
              minuet::persistent_state().fan_on = false;
              id(minuet_thermostat_reset_override).execute();
            } else {
              id(minuet_thermostat_update).execute();
            }

### PACKAGE: AUDIBLE FEEDBACK
#
# Plays tones in response to certain user interactions.
# Can be disabled in software or in hardware.
minuet_tone:
  substitutions:
    # Tones specified in the RTTTL language
    # Tones whose names start with '!' are important and cannot be suppressed
    #
    # Design guidelines:
    # - Tones start on E6
    # - Incrementing a value rises to G6
    # - Decrementing a value falls to C6
    # - Enabling a feature rises to A6
    # - Disabling a feature falls to A5
    # - Resetting a feature is a turn of E6, F6, E6, D6, E6
    # - Play tones only for actions whose effect cannot be immediately observed
    #   such as changing the thermostat temperature and don't play tones for actions
    #   whose effect can be immediately observed such as changing the fan speed
    # - Of course, if you're customizing this firmware you can change the tones to
    #   anything you like!
    #
    # Useful tool for testing tones: https://adamonsoon.github.io/rtttl-play/
    minuet_tones: |-
      // Generic tones
      "beep:d=16,o=4,b=144:e6",
      "!urgent:d=16,o=4,b=144:32e6,32p,e6",
      "forbidden:d=16,o=4,b=144:32e6,32p,32e6,32p,32e6",
      "minuet:d=4,o=4,b=152:d5,8g4,8a4,8b4,8c5,d5,g4,g4,e5,32c5,32b4,16c5,8d5,8e5,8f#5,g5,g4,g4,32c5,32b4,16c5,8d5,8c5,8b4,8a4,b4,8c5,8b4,8a4,8g4,f#4,8g4,8a4,8b4,8g4,32b4,2a4.,d5,8g4,8a4,8b4,8c5,d5,g4,g4,e5,32c5,32b4,16c5,8d5,8e5,8f#5,g5,g4,g4,32c5,32b4,16c5,8d5,8c5,8b4,8a4,b4,8c5,8b4,8a4,8g4,a4,8b4,8a4,8g4,8f#4,2g4.",
      // Specific actions
      "manual_fan_on:",
      "manual_fan_off:",
      "manual_speed_up:",
      "manual_speed_down:",
      "manual_dir_in:",
      "manual_dir_out:",
      "manual_lid_open:",
      "manual_lid_close:",
      "auto_on:",
      "auto_off:",
      "auto_reset:d=16,o=4,b=144:32e6,32f6,32e6,32d6,8e6",
      "auto_temp_up:d=16,o=4,b=144:e6,g6",
      "auto_temp_down:d=16,o=4,b=144:e6,c6",
      "auto_dir_in:d=16,o=4,b=144:32e6,32d6,8c6",
      "auto_dir_out:d=16,o=4,b=144:32e6,32f6,8g6",
      "auto_dir_default:d=16,o=4,b=144:32e6,32p,8e6",
      "auto_function_1:d=16,o=4,b=144:e6,p,32e6",
      "auto_function_2:d=16,o=4,b=144:e6,p,32e6,32p,32e6",
      "auto_function_3:d=16,o=4,b=144:e6,p,32e6,32p,32e6,32p,32e6",
      "auto_function_4:d=16,o=4,b=144:e6,p,32e6,32p,32e6,32p,32e6,32p,32e6",
      "rain_on:",
      "rain_off:",
      "ir_confirm:",
      "ir_warn:d=16,o=4,b=144:32e6,32p,e6",
      "!lock_on:d=16,o=4,b=144:32e6,32p,32e6,32p,8a6",
      "!lock_off:d=16,o=4,b=144:32e6,32p,32e6,32p,8a5",
      "!controls_enhanced:d=16,o=4,b=144:32e6,32p,32e6,32p,32e6,32p,8a6",
      "!controls_standard:d=16,o=4,b=144:32e6,32p,32e6,32p,32e6,32p,8a5",
      "!wifi_on:d=16,o=4,b=144:32e6,32p,32e6,32p,32e6,32p,32e6,32p,8a6",
      "!wifi_off:d=16,o=4,b=144:32e6,32p,32e6,32p,32e6,32p,32e6,32p,8a5",
      "!power_on_restore:d=16,o=4,b=144:32e6,32f6,32e6,32d6,8e6,8a6",
      "!power_on_default:d=16,o=4,b=144:32e6,32f6,32e6,32d6,8e6,8a5",
      "!factory_reset:d=16,o=4,b=144:8e6,8a5,8e5,a4",
      "!failsafe_restart:d=16,o=4,b=144:32e6,32p,32e6,32p,32e6,32p,32e6,32p,e6",
      "!fan_driver_fault:d=16,o=4,b=144:32e6,32p,32e6,32p,32e6",
    minuet_tone_default_if_unknown: "beep"
  output:
    - id: minuet_tone_pwm
      platform: ledc
      pin:
        number: 10
        mode: output
        inverted: false
      channel: 3
  rtttl:
    - id: minuet_tone_generator
      output: minuet_tone_pwm
  switch:
    - id: minuet_tone_enable
      name: "Audible feedback"
      icon: mdi:volume-high
      entity_category: config
      platform: template
      optimistic: true
      restore_mode: RESTORE_DEFAULT_ON
      on_turn_off:
        then:
          - rtttl.stop:
  api:
    actions:
      - action: play_tone
        variables:
          name: string
        then:
          - lambda: id(minuet_tone)->execute(name);
      - action: play_tone_rtttl
        variables:
          tone: string
        then:
          - lambda: id(minuet_tone_rtttl)->execute(tone);
      - action: stop_tone
        then:
          - rtttl.stop:
  script:
    - id: minuet_tone
      parameters:
        name: string
      then:
        - lambda: |-
            constexpr const char* tones[] = { ${minuet_tones} };
            constexpr const char* default_if_unknown = "${minuet_tone_default_if_unknown}";
            for (;;) {
              for (size_t i = 0; i < sizeof(tones) / sizeof(tones[0]); i++) {
                const char* tone = tones[i];
                char* colon_pos = strchr(tone, ':');
                if (!colon_pos) {
                  ESP_LOGD(minuet::TAG, "RTTTL tone missing name: '%s'", tone);
                  continue;
                }
                size_t name_length = colon_pos - tone;
                if (name.size() == name_length && strncmp(name.c_str(), tone, name_length) == 0) {
                  if (colon_pos[1]) { // ensure tone is not empty
                    id(minuet_tone_rtttl)->execute(colon_pos - 1);
                  }
                  return;
                }
              }
              ESP_LOGD(minuet::TAG, "RTTTL tone not found: '%s'", name.c_str());
              if (name == default_if_unknown) {
                return;
              }
              name = default_if_unknown;
            }
    - id: minuet_tone_rtttl
      parameters:
        tone: string
      then:
        - lambda: |-
            if (id(minuet_tone_enable).state || tone[0] == '!') {
              id(minuet_tone_generator).play(tone);
            }
  button:
    - id: minuet_beep
      name: Beep
      icon: mdi:alert
      disabled_by_default: true
      entity_category: config
      platform: template
      on_press:
        then:
          - script.execute:
              id: minuet_tone
              name: beep

### PACKAGE: KEYPAD CONTROL
#
# Reads the keypad state.
# Determines an action based on which keys are pressed or held.
# Refer to the user guide for the control scheme.
minuet_keypad_control:
  globals:
    - id: minuet_keypad_bouncy_key_state
      type: uint32_t
      restore_value: false
      initial_value: "0"
    - id: minuet_keypad_bouncy_key_time
      type: uint32_t
      restore_value: false
      initial_value: "millis()"
    - id: minuet_keypad_last_key_state
      type: uint32_t
      restore_value: false
      initial_value: "0"
    - id: minuet_keypad_last_key_valid
      type: bool
      restore_value: false
      initial_value: "false"
    - id: minuet_keypad_last_key_time
      type: uint32_t
      restore_value: false
      initial_value: "0"
    - id: minuet_keypad_pending_auto_power_count
      type: uint8_t
      restore_value: false
      initial_value: "0"
    - id: minuet_keypad_pending_auto_direction_count
      type: uint8_t
      restore_value: false
      initial_value: "0"
    - id: minuet_keypad_auto_indicator_state
      type: bool
      restore_value: false
      initial_value: "false"
    - id: minuet_keypad_auto_indicator_blinks
      type: uint8_t
      restore_value: false
      initial_value: "0"
    - id: minuet_keypad_auto_indicator_condition
      type: uint8_t
      restore_value: false
      initial_value: "0"
    - id: minuet_keypad_auto_indicator_duration
      type: uint8_t
      restore_value: false
      initial_value: "0"
    - id: minuet_keypad_rain_indicator_state
      type: bool
      restore_value: false
      initial_value: "false"
    - id: minuet_keypad_rain_indicator_blinks
      type: uint8_t
      restore_value: false
      initial_value: "0"
    - id: minuet_keypad_rain_indicator_condition
      type: uint8_t
      restore_value: false
      initial_value: "0"
    - id: minuet_keypad_rain_indicator_duration
      type: uint8_t
      restore_value: false
      initial_value: "0"
    - id: minuet_keypad_key_pressed_since_indicator_update
      type: bool
      restore_value: false
      initial_value: "false"
    - id: minuet_keypad_wifi_switch # Injected by wifi.yaml
      type: Switch*
      restore_value: false
      initial_value: "nullptr"
    - id: minuet_keypad_accessory_toggle # Injected by accessories
      type: bool(*)()
      restore_value: false
      initial_value: "nullptr"
    - id: minuet_keypad_accessory_up # Injected by accessories
      type: bool(*)()
      restore_value: false
      initial_value: "nullptr"
    - id: minuet_keypad_accessory_down # Injected by accessories
      type: bool(*)()
      restore_value: false
      initial_value: "nullptr"
  button:
    - id: minuet_restart
      platform: restart
      name: Restart
      icon: mdi:restart
      disabled_by_default: true
      entity_category: config
    - id: minuet_factory_reset
      platform: factory_reset
      name: Factory reset
      icon: mdi:restart-alert
      disabled_by_default: true
      entity_category: config
    - id: minuet_factory_reset_after_delay
      platform: template
      on_press:
        then:
          - delay: 2s
          - button.press: minuet_factory_reset
  switch:
    - id: minuet_keypad_indicators_suppressed
      name: "Keypad indicators suppressed"
      icon: mdi:led-on
      entity_category: config
      platform: template
      optimistic: true
      restore_mode: RESTORE_DEFAULT_OFF
  output:
    - id: minuet_keypad_auto_indicator
      platform: gpio
      pin:
        pca9554: minuet_xio
        number: 0
        mode: output
        inverted: true
    - id: minuet_keypad_rain_indicator
      platform: gpio
      pin:
        pca9554: minuet_xio
        number: 1
        mode: output
        inverted: true
  interval:
    - interval: 10ms
      then:
        lambda: |-
          ${minuet_to_celsius_macro}

          // Determine which menu of keypad actions is active.
          enum class Menu {
            STANDARD_MANUAL, STANDARD_AUTO, ENHANCED,
          };
          const auto which_menu = []() -> Menu {
            if (id(minuet_controls).active_index() == 0 /*Enhanced*/) return Menu::ENHANCED;
            return id(minuet_thermostat).mode == CLIMATE_MODE_OFF ? Menu::STANDARD_MANUAL : Menu::STANDARD_AUTO;
          };

          // Declare all of the possible actions
          // This code might be tidier in separate functions but that would require putting them
          // in a separate header file which is less convenient
          const auto do_press_power = [which_menu]() {
            const auto menu = which_menu();
            if (menu == Menu::STANDARD_AUTO) {
              auto& therm = id(minuet_thermostat);
              therm->make_call().set_mode(CLIMATE_MODE_OFF).perform();
              id(minuet_tone)->execute("auto_off");
            } else {
              auto& fan = id(minuet_fan);
              if (fan->state) {
                fan->turn_off().perform();
                id(minuet_tone)->execute("manual_fan_off");
              } else {
                fan->turn_on().perform();
                id(minuet_tone)->execute("manual_fan_on");
              }
            }
          };
          const auto do_press_4_on = [which_menu]() {
            auto& fan = id(minuet_fan);
            if (fan->state) {
              const auto SPEED_CYCLE = { 1, 3, 7, 10, };
              const auto it = std::find_if(SPEED_CYCLE.begin(), SPEED_CYCLE.end(), [](int speed) { return speed > fan->speed; });
              const bool going_up = it != SPEED_CYCLE.end();
              fan->make_call().set_speed(going_up ? *it : *SPEED_CYCLE.begin()).perform();
              id(minuet_tone)->execute(going_up ? "manual_speed_up" : "manual_speed_down");
            } else {
              fan->turn_on().perform();
              id(minuet_tone)->execute("manual_fan_on");
            }
          };
          const auto do_press_4_off = [which_menu]() {
            auto& fan = id(minuet_fan);
            fan->turn_off().perform();
            id(minuet_tone)->execute("manual_fan_off");
          };
          const auto do_press_up = [which_menu]() {
            const auto menu = which_menu();
            if (menu == Menu::STANDARD_AUTO) {
              auto& therm = id(minuet_thermostat);
              therm->make_call().set_target_temperature(therm->target_temperature + 1.f / 1.8f).perform();
              id(minuet_tone)->execute("auto_temp_up");
            } else {
              auto& fan = id(minuet_fan);
              if (fan->state) {
                fan->make_call().set_speed(fan->speed + 1).perform();
                id(minuet_tone)->execute("manual_speed_up");
              }
            }
          };
          const auto do_hold_up = [which_menu]() -> bool {
            const auto menu = which_menu();
            if (menu != Menu::STANDARD_AUTO) {
              auto& fan = id(minuet_fan);
              if (fan->state) {
                fan->make_call().set_speed(fan->get_traits().supported_speed_count()).perform();
                id(minuet_tone)->execute("manual_speed_up");
              }
              return true;
            }
            return false;
          };
          const auto do_press_down = [which_menu]() {
            const auto menu = which_menu();
            if (menu == Menu::STANDARD_AUTO) {
              auto& therm = id(minuet_thermostat);
              therm->make_call().set_target_temperature(therm->target_temperature - 1.f / 1.8f).perform();
                id(minuet_tone)->execute("auto_temp_down");
            } else {
              auto& fan = id(minuet_fan);
              if (fan->state) {
                fan->make_call().set_speed(fan->speed - 1).perform();
                id(minuet_tone)->execute("manual_speed_down");
              }
            }
          };
          const auto do_hold_down = [which_menu]() -> bool {
            const auto menu = which_menu();
            if (menu != Menu::STANDARD_AUTO) {
              auto& fan = id(minuet_fan);
              if (fan->state) {
                fan->make_call().set_speed(1).perform();
                id(minuet_tone)->execute("manual_speed_down");
              }
              return true;
            }
            return false;
          };
          const auto do_press_open_close = [which_menu]() {
            const auto menu = which_menu();
            if (menu != Menu::STANDARD_AUTO) {
              auto& lid = id(minuet_lid);
              if (id(minuet_lid).is_fully_closed()) {
                lid->make_call().set_command_open().perform();
                id(minuet_tone)->execute("manual_lid_open");
              } else {
                lid->make_call().set_command_close().perform();
                id(minuet_tone)->execute("manual_lid_close");
              }
            }
          };
          const auto do_press_4_open = [which_menu]() {
            auto& lid = id(minuet_lid);
            lid->make_call().set_command_open().perform();
            id(minuet_tone)->execute("manual_lid_open");
          };
          const auto do_press_4_close = [which_menu]() {
            auto& lid = id(minuet_lid);
            lid->make_call().set_command_close().perform();
            id(minuet_tone)->execute("manual_lid_close");
          };
          const auto do_press_direction = [which_menu]() {
            auto& fan = id(minuet_fan);
            if (fan->state) {
              const bool exhaust = !minuet::fan_direction_is_exhaust(fan->direction);
              fan->make_call().set_direction(minuet::fan_direction(exhaust)).perform();
              id(minuet_tone)->execute(exhaust ? "manual_dir_out" : "manual_dir_in");
            }
          };
          const auto do_press_auto = [which_menu]() {
            const auto menu = which_menu();
            if (menu == Menu::STANDARD_AUTO) {
              auto& therm = id(minuet_thermostat);
              therm->make_call().set_mode(CLIMATE_MODE_OFF).perform();
              id(minuet_tone)->execute("auto_off");
            } else if (menu == Menu::STANDARD_MANUAL) {
              auto& therm = id(minuet_thermostat);
              therm->make_call().set_mode(CLIMATE_MODE_COOL).perform();
              id(minuet_tone)->execute("auto_on");
            } else {
              auto& therm = id(minuet_thermostat);
              if (therm->mode == CLIMATE_MODE_OFF) {
                therm->make_call().set_mode(CLIMATE_MODE_COOL).perform();
                id(minuet_tone)->execute("auto_on");
              } else if (id(minuet_thermostat_override)) {
                id(minuet_thermostat_reset_override).execute();
                id(minuet_tone)->execute("auto_on");
              } else {
                therm->make_call().set_mode(CLIMATE_MODE_OFF).perform();
                id(minuet_tone)->execute("auto_off");
              }
            }
          };
          const auto do_press_auto_up = [which_menu]() {
            const auto menu = which_menu();
            if (menu == Menu::ENHANCED) {
              auto& therm = id(minuet_thermostat);
              therm->make_call().set_target_temperature(therm->target_temperature + 1.f / 1.8f).perform();
              id(minuet_tone)->execute("auto_temp_up");
            }
          };
          const auto do_press_auto_down = [which_menu]() {
            const auto menu = which_menu();
            if (menu == Menu::ENHANCED) {
              auto& therm = id(minuet_thermostat);
              therm->make_call().set_target_temperature(therm->target_temperature - 1.f / 1.8f).perform();
              id(minuet_tone)->execute("auto_temp_down");
            }
          };
          const auto do_press_auto_power = [which_menu]() {
            id(minuet_keypad_pending_auto_power_count) += 1;
          };
          const auto do_pending_auto_power = [which_menu](uint8_t count) {
            const auto menu = which_menu();
            if (menu == Menu::ENHANCED) {
              switch (count) {
                case 1:
                  id(minuet_thermostat).make_call().set_fan_mode(ClimateFanMode::CLIMATE_FAN_AUTO).perform();
                  id(minuet_thermostat_lid_mode).make_call().set_index(0).perform();
                  id(minuet_tone)->execute("auto_function_1");
                  break;
                case 2:
                  id(minuet_thermostat).make_call().set_fan_mode(ClimateFanMode::CLIMATE_FAN_QUIET).perform();
                  id(minuet_thermostat_lid_mode).make_call().set_index(1).perform();
                  id(minuet_tone)->execute("auto_function_2");
                  break;
                case 3:
                  id(minuet_thermostat).make_call().set_fan_mode(ClimateFanMode::CLIMATE_FAN_LOW).perform();
                  id(minuet_thermostat_lid_mode).make_call().set_index(0).perform();
                  id(minuet_tone)->execute("auto_function_3");
                  break;
                case 4:
                  id(minuet_thermostat).make_call().set_fan_mode(ClimateFanMode::CLIMATE_FAN_OFF).perform();
                  id(minuet_thermostat_lid_mode).make_call().set_index(0).perform();
                  id(minuet_tone)->execute("auto_function_4");
                  break;
              }
            }
          };
          const auto do_press_auto_direction = [which_menu]() {
            id(minuet_keypad_pending_auto_direction_count) += 1;
          };
          const auto do_pending_auto_direction = [which_menu](uint8_t count) {
            const auto menu = which_menu();
            if (menu == Menu::ENHANCED) {
              switch (count) {
                case 1:
                  id(minuet_thermostat_fan_direction).make_call().set_index(0).perform();
                  id(minuet_tone)->execute("auto_dir_default");
                  break;
                case 2:
                  id(minuet_thermostat_fan_direction).make_call().set_index(1).perform();
                  id(minuet_tone)->execute("auto_dir_out");
                  break;
                case 3:
                  id(minuet_thermostat_fan_direction).make_call().set_index(2).perform();
                  id(minuet_tone)->execute("auto_dir_in");
                  break;
              }
            }
          };
          const auto do_hold_auto = [which_menu]() -> bool {
            const auto menu = which_menu();
            if (menu == Menu::ENHANCED || menu == Menu::STANDARD_AUTO) {
              id(minuet_thermostat).make_call()
                  .set_target_temperature(${to_celsius(minuet_thermostat_reset_temperature)})
                  .set_fan_mode(ClimateFanMode::CLIMATE_FAN_AUTO)
                  .perform();
              id(minuet_thermostat_fan_direction).make_call().select_first().perform();
              id(minuet_thermostat_lid_mode).make_call().select_first().perform();
              id(minuet_tone)->execute("auto_reset");
              return true;
            }
            return false;
          };
          const auto do_press_rain = [which_menu]() {
            if (id(minuet_rain_stopped_fan).state || !id(minuet_rain_sensor_enabled).state) {
              id(minuet_rain_sensor_reset).press();
              id(minuet_tone)->execute("rain_on");
            } else {
              id(minuet_rain_sensor_enabled).turn_off();
              id(minuet_tone)->execute("rain_off");
            }
          };
          const auto do_hold_use_enhanced_controls = [which_menu]() -> bool {
            id(minuet_controls).make_call().set_index(0).perform();
            id(minuet_tone)->execute("!controls_enhanced");
            return true;
          };
          const auto do_hold_use_standard_controls = [which_menu]() -> bool {
            id(minuet_controls).make_call().set_index(1).perform();
            id(minuet_tone)->execute("!controls_standard");
            return true;
          };
          const auto do_hold_keypad_indicators_toggle = [which_menu]() -> bool {
            auto& indicator_switch = id(minuet_keypad_indicators_suppressed);
            indicator_switch->toggle();
            id(minuet_keypad_auto_indicator_blinks) = id(minuet_keypad_rain_indicator_blinks) = indicator_switch->state ? 10 : 14;
            return true;
          };
          const auto do_hold_wifi_toggle = [which_menu]() -> bool {
            const auto& wifi_switch = id(minuet_keypad_wifi_switch);
            if (wifi_switch) {
              wifi_switch->toggle();
              id(minuet_tone)->execute(wifi_switch->state ? "!wifi_on" : "!wifi_off");
              return true;
            }
            return false;
          };
          const auto do_hold_power_on_behavior_toggle = [which_menu]() -> bool {
            auto& behavior = id(minuet_power_on_behavior);
            behavior->make_call().select_next(true).perform();
            id(minuet_tone)->execute(behavior->active_index() == 1 ? "!power_on_restore" : "!power_on_default");
            return true;
          };
          const auto do_hold_manual_safety_lock_toggle = [which_menu]() -> bool {
            auto& lock_switch = id(minuet_manual_safety_lock);
            lock_switch->toggle();
            id(minuet_tone)->execute(lock_switch->state ? "!lock_on" : "!lock_off");
            return true;
          };
          const auto do_hold_factory_reset = [which_menu]() -> bool {
            id(minuet_factory_reset_after_delay).press();
            id(minuet_tone)->execute("!factory_reset");
            return true;
          };
          const auto do_hold_accessory_toggle = [which_menu]() -> bool {
            const auto& fn = id(minuet_keypad_accessory_toggle);
            return !!fn && fn();
          };
          const auto do_press_accessory_up = [which_menu]() -> bool {
            const auto& fn = id(minuet_keypad_accessory_up);
            return !!fn && fn();
          };
          const auto do_press_accessory_down = [which_menu]() -> bool {
            const auto& fn = id(minuet_keypad_accessory_down);
            return !!fn && fn();
          };

          // Scan the keypad matrix
          // All of the pins have internal pull-up resistors
          constexpr uint8_t XIO_PIN_R1 = 5;
          constexpr uint8_t XIO_PIN_R2 = 3;
          constexpr uint8_t XIO_PIN_C1 = 7;
          constexpr uint8_t XIO_PIN_C2 = 4;
          constexpr uint8_t XIO_PIN_C3 = 2;
          constexpr uint8_t XIO_PIN_C4 = 6;
          auto& xio = id(minuet_xio);

          // Read the keypad row pins themselves while they are undriven
          // to detect OPEN and CLOSE on the 4 key keypad
          const bool key_r1_gnd = !xio->digital_read(XIO_PIN_R1);
          const bool key_r2_gnd = !xio->digital_read(XIO_PIN_R2);

          // Drive keypad row 1 low and read the columns
          xio->pin_mode(XIO_PIN_R1, gpio::FLAG_OUTPUT);
          xio->loop();
          const bool key_r1_c1 = !xio->digital_read(XIO_PIN_C1);
          const bool key_r1_c2 = !xio->digital_read(XIO_PIN_C2);
          const bool key_r1_c3 = !xio->digital_read(XIO_PIN_C3);
          const bool key_r1_c4 = !xio->digital_read(XIO_PIN_C4);
          xio->pin_mode(XIO_PIN_R1, gpio::FLAG_INPUT);

          // Drive keypad row 2 low and read the columns
          xio->pin_mode(XIO_PIN_R2, gpio::FLAG_OUTPUT);
          xio->loop();
          const bool key_r2_c1 = !xio->digital_read(XIO_PIN_C1);
          const bool key_r2_c2 = !xio->digital_read(XIO_PIN_C2);
          const bool key_r2_c3 = !xio->digital_read(XIO_PIN_C3);
          const bool key_r2_c4 = !xio->digital_read(XIO_PIN_C4);
          xio->pin_mode(XIO_PIN_R2, gpio::FLAG_INPUT);

          // Combine all of the key states into a single value with one bit per key
          // that represents the complete state of the keypad
          constexpr uint32_t KEY_UP = 1u << 0;
          constexpr uint32_t KEY_DOWN = 1u << 1;
          constexpr uint32_t KEY_RAIN = 1u << 2;
          constexpr uint32_t KEY_POWER = 1u << 3;
          constexpr uint32_t KEY_DIRECTION = 1u << 4;
          constexpr uint32_t KEY_AUTO = 1u << 5;
          constexpr uint32_t KEY_4_CLOSE = 1u << 6;
          constexpr uint32_t KEY_4_OPEN = 1u << 7;
          constexpr uint32_t KEY_4_OFF = 1u << 8;
          constexpr uint32_t KEY_4_ON = 1u << 9;
          const uint32_t key_state =
              (key_r1_c2 ? KEY_UP : 0) |
              (key_r1_c3 ? KEY_DOWN : 0) |
              (key_r1_c4 ? KEY_RAIN : 0) |
              (key_r2_c2 ? KEY_POWER : 0) |
              (key_r2_c3 ? KEY_DIRECTION : 0) |
              (key_r2_c4 ? KEY_AUTO : 0) |
              (key_r1_gnd ? KEY_4_CLOSE : 0) |
              (key_r2_gnd ? KEY_4_OPEN : 0) |
              (key_r1_c1 ? KEY_4_OFF : 0) |
              (key_r2_c1 ? KEY_4_ON : 0);

          // Debounce the keys
          constexpr uint32_t DEBOUNCE_DURATION = 40;
          auto& bouncy_key_state = id(minuet_keypad_bouncy_key_state);
          auto& bouncy_key_time = id(minuet_keypad_bouncy_key_time);
          if (key_state != bouncy_key_state) {
            bouncy_key_state = key_state;
            bouncy_key_time = millis();
            return; // wait for key state to be debounced before processing it
          }
          if (millis() - bouncy_key_time < DEBOUNCE_DURATION) {
            return; // wait for key state to be debounced before processing it
          }

          // Check whether this key combination is potentially valid
          constexpr uint32_t KEY_COMBO_OPEN_CLOSE = KEY_UP | KEY_DOWN;
          constexpr uint32_t KEY_COMBO_AUTO_UP = KEY_AUTO | KEY_UP;
          constexpr uint32_t KEY_COMBO_AUTO_DOWN = KEY_AUTO | KEY_DOWN;
          constexpr uint32_t KEY_COMBO_AUTO_DIRECTION = KEY_AUTO | KEY_DIRECTION;
          constexpr uint32_t KEY_COMBO_AUTO_POWER = KEY_AUTO | KEY_POWER;
          constexpr uint32_t KEY_COMBO_AUTO_OPEN_CLOSE = KEY_AUTO | KEY_COMBO_OPEN_CLOSE;
          constexpr uint32_t KEY_COMBO_POWER_UP = KEY_POWER | KEY_UP;
          constexpr uint32_t KEY_COMBO_POWER_DOWN = KEY_POWER | KEY_DOWN;
          constexpr uint32_t KEY_COMBO_POWER_DIRECTION = KEY_POWER | KEY_DIRECTION;
          constexpr uint32_t KEY_COMBO_DIRECTION_UP = KEY_DIRECTION | KEY_UP;
          constexpr uint32_t KEY_COMBO_DIRECTION_DOWN = KEY_DIRECTION | KEY_DOWN;
          const auto VALID_KEY_COMBOS = {
              KEY_UP, KEY_DOWN, KEY_RAIN, KEY_POWER, KEY_DIRECTION, KEY_AUTO,
              KEY_4_CLOSE, KEY_4_OPEN, KEY_4_OFF, KEY_4_ON,
              KEY_COMBO_OPEN_CLOSE,
              KEY_COMBO_AUTO_UP, KEY_COMBO_AUTO_DOWN, KEY_COMBO_AUTO_DIRECTION, KEY_COMBO_AUTO_POWER, KEY_COMBO_AUTO_OPEN_CLOSE,
              KEY_COMBO_POWER_UP, KEY_COMBO_POWER_DOWN, KEY_COMBO_POWER_DIRECTION,
              KEY_COMBO_DIRECTION_UP, KEY_COMBO_DIRECTION_DOWN,
          };
          bool key_valid = std::find(VALID_KEY_COMBOS.begin(), VALID_KEY_COMBOS.end(), key_state) != VALID_KEY_COMBOS.end();

          // Key dispatching
          constexpr uint32_t MIN_PRESS_DURATION = 100;
          constexpr uint32_t MAX_PRESS_DURATION = 800;
          constexpr uint32_t MIN_HOLD_UP_DOWN_DURATION = 1000;
          constexpr uint32_t MIN_HOLD_ACCESSORY_TOGGLE_DURATION = 1000;
          constexpr uint32_t MIN_HOLD_AUTO_DURATION = 3000;
          constexpr uint32_t MIN_HOLD_SETTING_DURATION = 5000;
          constexpr uint32_t MIN_HOLD_FACTORY_RESET_DURATION = 15000;
          const auto log_press = [](const char* key) {
            ESP_LOGD(minuet::TAG, "Key press: %s", key);
          };
          const auto do_press = [=](uint32_t key_state, uint32_t press_duration) {
            if (press_duration >= MIN_PRESS_DURATION && press_duration <= MAX_PRESS_DURATION) {
              if (key_state == KEY_UP) {
                log_press("KEY_UP");
                do_press_up();
              } else if (key_state == KEY_DOWN) {
                log_press("KEY_DOWN");
                do_press_down();
              } else if (key_state == KEY_RAIN) {
                log_press("KEY_RAIN");
                do_press_rain();
              } else if (key_state == KEY_POWER) {
                log_press("KEY_POWER");
                do_press_power();
              } else if (key_state == KEY_DIRECTION) {
                log_press("KEY_DIRECTION");
                do_press_direction();
              } else if (key_state == KEY_AUTO) {
                log_press("KEY_AUTO");
                do_press_auto();
              } else if (key_state == KEY_4_ON) {
                log_press("KEY_4_ON");
                do_press_4_on();
              } else if (key_state == KEY_4_OFF) {
                log_press("KEY_4_OFF");
                do_press_4_off();
              } else if (key_state == KEY_4_OPEN) {
                log_press("KEY_4_OPEN");
                do_press_4_open();
              } else if (key_state == KEY_4_CLOSE) {
                log_press("KEY_4_CLOSE");
                do_press_4_close();
              } else if (key_state == KEY_COMBO_OPEN_CLOSE) {
                log_press("KEY_COMBO_OPEN_CLOSE");
                do_press_open_close();
              } else if (key_state == KEY_COMBO_AUTO_UP) {
                log_press("KEY_COMBO_AUTO_UP");
                do_press_auto_up();
              } else if (key_state == KEY_COMBO_AUTO_DOWN) {
                log_press("KEY_COMBO_AUTO_DOWN");
                do_press_auto_down();
              } else if (key_state == KEY_COMBO_AUTO_DIRECTION) {
                log_press("KEY_COMBO_AUTO_DIRECTION");
                do_press_auto_direction();
              } else if (key_state == KEY_COMBO_AUTO_POWER) {
                log_press("KEY_COMBO_AUTO_POWER");
                do_press_auto_power();
              } else if (key_state == KEY_COMBO_DIRECTION_UP) {
                log_press("KEY_COMBO_DIRECTION_UP");
                do_press_accessory_up();
              } else if (key_state == KEY_COMBO_DIRECTION_DOWN) {
                log_press("KEY_COMBO_DIRECTION_DOWN");
                do_press_accessory_down();
              }
            }
          };
          const auto log_hold = [](const char* key) {
            ESP_LOGD(minuet::TAG, "Key hold: %s", key);
          };
          const auto do_hold = [=](uint32_t key_state, uint32_t hold_duration) -> bool {
            if (key_state == KEY_UP && hold_duration >= MIN_HOLD_UP_DOWN_DURATION) {
              log_hold("KEY_UP");
              return do_hold_up();
            } else if (key_state == KEY_DOWN && hold_duration >= MIN_HOLD_UP_DOWN_DURATION) {
              log_hold("KEY_DOWN");
              return do_hold_down();
            } else if (key_state == KEY_DIRECTION && hold_duration >= MIN_HOLD_ACCESSORY_TOGGLE_DURATION) {
              log_hold("KEY_DIRECTION");
              return do_hold_accessory_toggle();
            } else if (key_state == KEY_AUTO && hold_duration >= MIN_HOLD_AUTO_DURATION) {
              log_hold("KEY_AUTO");
              return do_hold_auto();
            } else if (key_state == KEY_COMBO_AUTO_UP && hold_duration >= MIN_HOLD_SETTING_DURATION) {
              log_hold("KEY_COMBO_AUTO_UP");
              return do_hold_use_enhanced_controls();
            } else if (key_state == KEY_COMBO_AUTO_DOWN && hold_duration >= MIN_HOLD_SETTING_DURATION) {
              log_hold("KEY_COMBO_AUTO_DOWN");
              return do_hold_use_standard_controls();
            } else if (key_state == KEY_COMBO_AUTO_OPEN_CLOSE && hold_duration >= MIN_HOLD_SETTING_DURATION) {
              log_hold("KEY_COMBO_AUTO_OPEN_CLOSE");
              return do_hold_keypad_indicators_toggle();
            } else if (key_state == KEY_COMBO_POWER_DOWN && hold_duration >= MIN_HOLD_SETTING_DURATION) {
              log_hold("KEY_COMBO_POWER_DOWN");
              return do_hold_wifi_toggle();
            } else if (key_state == KEY_COMBO_POWER_UP && hold_duration >= MIN_HOLD_SETTING_DURATION) {
              log_hold("KEY_COMBO_POWER_UP");
              return do_hold_power_on_behavior_toggle();
            } else if (key_state == KEY_COMBO_POWER_DIRECTION && hold_duration >= MIN_HOLD_SETTING_DURATION) {
              log_hold("KEY_COMBO_POWER_DIRECTION");
              return do_hold_manual_safety_lock_toggle();
            } else if (key_state == KEY_POWER && hold_duration >= MIN_HOLD_FACTORY_RESET_DURATION) {
              log_hold("KEY_POWER");
              return do_hold_factory_reset();
            }
            return false;
          };

          // Wake up suppressed indicators
          if (key_state) {
            id(minuet_keypad_key_pressed_since_indicator_update) = true;
          }

          // Handle pending multiple-tap key presses after the modifier has been released
          auto& pending_auto_power_count = id(minuet_keypad_pending_auto_power_count);
          if (key_state == 0 && pending_auto_power_count) {
            do_pending_auto_power(pending_auto_power_count);
            pending_auto_power_count = 0;
          }
          auto& pending_auto_direction_count = id(minuet_keypad_pending_auto_direction_count);
          if (key_state == 0 && pending_auto_direction_count) {
            do_pending_auto_direction(pending_auto_direction_count);
            pending_auto_direction_count = 0;
          }

          // Detect key presses
          auto& last_key_state = id(minuet_keypad_last_key_state);
          auto& last_key_valid = id(minuet_keypad_last_key_valid);
          auto& last_key_time = id(minuet_keypad_last_key_time);
          if (key_state == 0 && last_key_valid) {
            // A key was released
            const uint32_t press_duration = millis() - last_key_time;
            do_press(last_key_state, press_duration);
          } else if (key_valid && last_key_state == 0) {
            // A key was pressed on its own
            last_key_time = millis();
          } else if (key_valid && key_state != last_key_state && key_state == (key_state | last_key_state)) {
            // A key was pressed that adds to a previously pressed key to form a combo
            last_key_time = millis();
          } else if (key_valid && last_key_valid && key_state == last_key_state) {
            // A key is being held
            const uint32_t hold_duration = millis() - last_key_time;
            if (do_hold(key_state, hold_duration)) {
              key_valid = false; // cancel further processing of this key
            }
          } else if (key_valid && key_state == KEY_AUTO && last_key_valid && (last_key_state & KEY_AUTO) != 0) {
            // A key that was previously combined with auto has been released while auto remains held
            const uint32_t press_duration = millis() - last_key_time;
            do_press(last_key_state, press_duration);
            key_valid = false; // cancel processing of the modifier itself
          } else if (key_valid && key_state == KEY_DIRECTION && last_key_valid && (last_key_state & KEY_DIRECTION) != 0) {
            // A key that was previously combined with direction has been released while direction remains held
            const uint32_t press_duration = millis() - last_key_time;
            do_press(last_key_state, press_duration);
            key_valid = false; // cancel processing of the modifier itself
          } else if (key_valid) {
            // A different key is pressed now than was pressed before and does not form a valid combo sequence
            key_valid = false; // cancel further processing of this key
          }
          last_key_state = key_state;
          last_key_valid = key_valid;
    - interval: 300ms
      then:
        - lambda: |-
            const bool key_pressed = id(minuet_keypad_key_pressed_since_indicator_update);
            id(minuet_keypad_key_pressed_since_indicator_update) = false;

            const auto update_indicator = [key_pressed](BinaryOutput* output,
                bool& state, uint8_t& blinks, uint8_t& duration, uint8_t& condition,
                uint8_t (*condition_func)()) {
              if (blinks) {
                blinks -= 1;
                state = (blinks & 2);
                duration = 0;
              } else {
                uint8_t new_condition = condition_func();
                if (condition != new_condition || key_pressed) {
                  condition = new_condition;
                  duration = 10;
                } else if (duration) {
                  duration -= 1;
                }
                if (!condition || !duration && id(minuet_keypad_indicators_suppressed).state) {
                  state = false;
                } else {
                  state = (condition == 1) ? !state : true;
                }
              }
              output->set_state(state);
            };

            update_indicator(id(minuet_keypad_auto_indicator),
                id(minuet_keypad_auto_indicator_state), id(minuet_keypad_auto_indicator_blinks),
                id(minuet_keypad_auto_indicator_duration), id(minuet_keypad_auto_indicator_condition),
                []() -> uint8_t {
                    if (id(minuet_thermostat).mode == CLIMATE_MODE_OFF) {
                      return 0;
                    } else if (id(minuet_thermostat_override)) {
                      return 1;
                    } else {
                      return 2;
                    }
                });

            update_indicator(id(minuet_keypad_rain_indicator),
                id(minuet_keypad_rain_indicator_state), id(minuet_keypad_rain_indicator_blinks),
                id(minuet_keypad_rain_indicator_duration), id(minuet_keypad_rain_indicator_condition),
                []() -> uint8_t {
                    if (!id(minuet_rain_sensor_enabled).state) {
                      return 2;
                    } else if (id(minuet_rain_stopped_fan).state) {
                      return 1;
                    } else {
                      return 0;
                    }
                });


### PACKAGE: INFRARED REMOTE CONTROL
#
# Receives and handles messages from the remote control.
minuet_ir_control:
  globals:
    - id: minuet_ir_control_accessory_nec # Injected from accessories
      type: void(*)(esphome::remote_base::NECData)
      restore_value: false
      initial_value: "nullptr"
  maxxfan_protocol:
  remote_receiver:
    - id: minuet_ir
      pin:
        number: 2
        mode: input
        inverted: true
        ignore_strapping_warning: true
      dump: [ maxxfan, nec ]
      on_maxxfan:
        then:
          lambda: |-
            auto& lid = id(minuet_lid);
            auto& fan = id(minuet_fan);
            auto& therm = id(minuet_thermostat);
            if (x.auto_mode) {
              fan->make_call()
                  .set_direction(minuet::fan_direction(x.fan_exhaust))
                  .perform();
              id(minuet_thermostat_fan_direction).make_call().set_index(0).perform();
              therm->make_call()
                  .set_mode(CLIMATE_MODE_COOL)
                  .set_target_temperature(fahrenheit_to_celsius(x.auto_temperature))
                  .perform();
              id(minuet_thermostat_reset_override).execute();
            } else {
              therm->make_call()
                  .set_mode(CLIMATE_MODE_OFF)
                  .set_target_temperature(fahrenheit_to_celsius(x.auto_temperature))
                  .perform();
              const bool fan_changing_states = fan->state != x.fan_on;
              id(minuet_fan_set).execute(x.fan_on, x.fan_speed / 10, x.fan_exhaust,
                  /*suppress_lid_movement*/ true, /*force*/ false);
              id(minuet_lid_set).execute(x.cover_open, fan_changing_states);
            }
            id(minuet_tone)->execute(x.warn ? "ir_warn" : "ir_confirm");
      on_nec:
        then:
          lambda: |-
            const auto& fn = id(minuet_ir_control_accessory_nec);
            if (!!fn) fn(x);

### PACKAGE: FAN CONTROLLER
#
# Defines the high-level fan entity.
# Distinguishes between state changes initiated by the user or from internal logic.
# Tells the fan motor driver what to do.
# Fan direction convention:
#   - FanDirection::REVERSE is air out / exhaust
#   - FanDirection::FORWARD is air in / intake
minuet_fan_controller:
  globals:
    - id: minuet_fan_suppress_lid_movement
      type: bool
      restore_value: false
      initial_value: "false"
  fan:
    - id: minuet_fan
      name: "Fan"
      platform: template
      has_direction: true
      speed_count: 10
      restore_mode: NO_RESTORE
      on_turn_on:
        then:
          - lambda: |-
              // Safety lock check: Lid must not open while the lock is on
              if (!id(minuet_fan_suppress_lid_movement) && !id(minuet_safety_lock).state) {
                id(minuet_lid).make_call().set_command_open().perform();
              }
      on_turn_off:
        then:
          - lambda: |-
              if (!id(minuet_fan_suppress_lid_movement)) {
                id(minuet_lid).make_call().set_command_close().perform();
              }
      on_state:
        then:
          - lambda: |-
              // Safety lock check: Fan must not run while the lock is on
              const auto& fan = id(minuet_fan);
              if (fan->state && id(minuet_safety_lock).state) {
                if (!minuet::is_transient_operation()) {
                  ESP_LOGI(minuet::TAG, "Safety lock prevented fan from being turned on: %s safety lock active",
                      id(minuet_safety_lock_reason).state.c_str());
                  id(minuet_tone)->execute("forbidden");
                  id(minuet_rain_safety_lock_maybe_triggered)->execute();
                }
                fan->make_call().set_state(false).perform();
              } else {
                if (!minuet::is_transient_operation()) {
                  id(minuet_snapshot_fan_persistent_state).execute();
                  id(minuet_thermostat_reconcile_fan_manual_state_change)->execute(fan->state, fan->speed, minuet::fan_direction_is_exhaust(fan->direction));
                }
                id(minuet_fan_control_update).execute();
              }
  switch:
    - id: minuet_fan_override
      name: "Fan override"
      icon: mdi:bug-outline
      platform: template
      restore_mode: DISABLED
      optimistic: true
      entity_category: config
      disabled_by_default: true
      on_state:
        then:
          - script.execute: minuet_fan_control_update
    - id: minuet_fan_override_brake
      name: "Fan override brake"
      icon: mdi:pause
      platform: template
      restore_mode: DISABLED
      optimistic: true
      entity_category: config
      disabled_by_default: true
      on_state:
        then:
          - script.execute: minuet_fan_control_update
    - id: minuet_fan_override_keep_awake
      name: "Fan override keep awake"
      icon: mdi:pause
      platform: template
      restore_mode: DISABLED
      optimistic: true
      entity_category: config
      disabled_by_default: true
      on_state:
        then:
          - script.execute: minuet_fan_control_update
  number:
    - id: minuet_fan_override_speed
      name: "Fan override speed"
      icon: mdi:square-wave
      unit_of_measurement: 'rpm'
      entity_category: config
      disabled_by_default: true
      platform: template
      min_value: 0
      max_value: 2000 # equal to MAX_SPEED_RPM
      step: 10
      mode: slider
      optimistic: true
      initial_value: 0
      restore_value: false
      on_value:
        then:
          - script.execute: minuet_fan_control_update
  select:
    - id: minuet_fan_override_direction
      platform: template
      name: "Fan override direction"
      entity_category: config
      disabled_by_default: true
      optimistic: true
      restore_value: false
      options:
        - Out
        - In
      on_value:
        then:
          - script.execute: minuet_fan_control_update
  script:
    - id: minuet_fan_set
      parameters:
        state: bool
        speed: int
        exhaust: bool
        suppress_lid_movement: bool
        force: bool
      then:
        - lambda: |-
            auto& fan = id(minuet_fan);
            if (force || fan->state != state || fan->speed != speed || fan->direction != minuet::fan_direction(exhaust)) {
              id(minuet_fan_suppress_lid_movement) = suppress_lid_movement;
              fan->make_call()
                  .set_state(state)
                  .set_speed(speed)
                  .set_direction(minuet::fan_direction(exhaust))
                  .perform();
              id(minuet_fan_suppress_lid_movement) = false;
            }
    - id: minuet_fan_control_update
      mode: queued
      then:
        - lambda: |-
            // Safety lock check: Fan must not run while the safety lock is on
            const auto& fan = id(minuet_fan);
            const bool fan_on = fan->state && !id(minuet_safety_lock).state;
            float speed_rpm;
            bool exhaust;
            bool brake;
            bool keep_awake;
            if (id(minuet_fan_override).state) {
              speed_rpm = fan_on ? id(minuet_fan_override_speed).state : 0;
              exhaust = id(minuet_fan_override_direction).active_index() == 0;
              brake = id(minuet_fan_override_brake).state;
              keep_awake = id(minuet_fan_override_keep_awake).state;
            } else {
              speed_rpm = fan_on ? minuet::fan_driver::controller.get_fan_speed_by_index(fan->speed) : 0;
              exhaust = minuet::fan_direction_is_exhaust(fan->direction);
              brake = false;
              keep_awake = false;
            }
            if (!minuet::fan_driver::controller.set_state(speed_rpm, exhaust, brake, keep_awake)) {
              ESP_LOGE(minuet::TAG, "Failed to set the fan driver state");
              if (fan->state) {
                fan->turn_off().perform();
              }
            }

### PACKAGE: LID CONTROLLER
#
# Defines the high-level cover entity to open or close the lid.
# Distinguishes between state changes initiated by the user or from internal logic.
# Tells the lid motor driver what to do.
minuet_lid_controller:
  globals:
    - id: minuet_lid_movement_interrupted
      type: bool
      restore_value: false
      initial_value: "false"
  cover:
    - id: minuet_lid
      name: "Lid"
      device_class: damper
      platform: template
      optimistic: false
      assumed_state: true
      restore_mode: NO_RESTORE
      open_action:
        then:
          - lambda: |-
              // Safety lock check: Lid must not open while the lock is on
              if (id(minuet_safety_lock).state) {
                if (!minuet::is_transient_operation()) {
                  ESP_LOGI(minuet::TAG, "Safety lock prevented lid from being opened: %s safety lock active",
                      id(minuet_safety_lock_reason).state.c_str());
                  id(minuet_tone)->execute("forbidden");
                  id(minuet_rain_safety_lock_maybe_triggered)->execute();
                }
              } else if (id(minuet_lid).current_operation != COVER_OPERATION_OPENING) {
                id(minuet_lid_perform_operation).execute(true);
              }
      close_action:
        then:
          - lambda: |-
              // Safety lock check: Lid can close regardless of the state of the lock
              if (id(minuet_lid).current_operation != COVER_OPERATION_CLOSING) {
                id(minuet_lid_perform_operation).execute(false);
              }
      toggle_action:
        then:
          - lambda: |-
              id(minuet_lid_set).execute(id(minuet_lid).is_fully_closed(), /*force*/ false);
  script:
    - id: minuet_lid_set
      parameters:
        open: bool
        force: bool
      then:
        - lambda: |-
            auto& lid = id(minuet_lid);
            if (open && (force || !minuet::cover_is_open_or_opening(lid))) {
              id(minuet_lid).make_call().set_command_open().perform();
            } else if (!open && (force || minuet::cover_is_open_or_opening(lid))) {
              id(minuet_lid).make_call().set_command_close().perform();
            }
    - id: minuet_lid_perform_operation
      mode: restart
      parameters:
        open: bool
      then:
        # Stop the motor first in case the previous operation was interrupted
        - lambda: |-
            id(minuet_lid_motor_sleep).turn_on();

            const auto& current_op = id(minuet_lid).current_operation;
            id(minuet_lid_movement_interrupted) =
                current_op == COVER_OPERATION_OPENING || current_op == COVER_OPERATION_CLOSING;

            id(minuet_lid).current_operation = open ? COVER_OPERATION_OPENING : COVER_OPERATION_CLOSING;
            id(minuet_lid).publish_state();

            if (!minuet::is_transient_operation()) {
              id(minuet_snapshot_lid_persistent_state).execute();
              id(minuet_thermostat_reconcile_lid_manual_state_change)->execute(open);
            }
        # Allow the motor's inertia to settle to avoid prematurely triggering a fault
        # when abruptly changing directions
        - if:
            condition:
              - lambda: 'return id(minuet_lid_movement_interrupted);'
            then:
              - logger.log: "Lid movement was interrupted, waiting for inertia to settle before changing directions"
              - delay: 2s
        # Start the motor
        - lambda: |-
            id(minuet_lid_motor_open).set_state(open);
            id(minuet_lid_motor_sleep).turn_off();
        # Wait for the motor to stall at end of travel or for a timeout to expire
        # The rain cover lid typically takes about 6 seconds to reach end of travel
        # The low profile lid typically takes about 12 seconds to reach end of travel
        # FIXME: Improve stall detection to allow the use of a single timeout for all lids
        - wait_until:
            condition:
              binary_sensor.is_on: minuet_lid_motor_fault
            timeout: 6s # Change if you have a different lid
        # Stop the motor and report completion
        - lambda: |-
            id(minuet_lid_motor_sleep).turn_on();

            id(minuet_lid).current_operation = COVER_OPERATION_IDLE;
            id(minuet_lid).position = open ? COVER_OPEN : COVER_CLOSED;
            id(minuet_lid).publish_state();

### PACKAGE: THERMOSTAT
#
# Controls the fan and lid based on the ambient temperature, when enabled.
#
# Both the user and the thermostat can modify the state of the fan and lid.
# To resolve this conflict, the thermostat sets the transient flag whenever it changes the state so
# that the fan and lid state change handlers can distinguish whether a given change was initiated
# by the user or by the thermostat.  Only changes made by the user are ever saved to flash.
# When the thermostat is disabled, it turns the fan off but restores the user's last commanded
# speed and direction.
#
# When using standard controls, the keypad forbids the user from changing the fan speed
# or lid position while the thermostat is enabled (because that's what the original firmware
# does).  However, the ESPHome API has no such constraints so if a manual change occurs
# through that interface then the thermostat is disabled to reconcile who's in charge.
#
# When using enhanced controls, the keypad allows the user to take control by incrementally
# modifying whatever state to which the thermostat last set the fan and lid.  The thermostat
# remains enabled but ignored until the override flag is reset.  The same behavior applies
# to changes intiated by the ESPHome API.
#
# This design was chosen so that the fan and lid entities always reflect the true
# state of the device (insofar as it knows) and it ensures a smooth handoff of control back
# to the user when the thermostat is disabled or overridden.
minuet_thermostat:
  substitutions:
    # Don't change these temperature values.
    # Refer to the implementation notes in README.md for details on why they were chosen.
    minuet_thermostat_reset_temperature: "78Â°F"
    minuet_thermostat_min_temperature: "-5Â°C"
    minuet_thermostat_max_temperature: "50Â°C"
    minuet_thermostat_visual_temperature_step: "0.5Â°C"
    # A macro for temperature unit conversion.
    minuet_to_celsius_macro: |-
      <% macro to_celsius(value) %>
        <% if value.endswith("Â°F") %>
          ${ ((value | replace("Â°F", "") | float(0)) - 32) * 5 / 9 }
        <% else %>
          ${ value | replace("Â°C", "") | float(0) }
        <% endif %>
      <% endmacro %>
  globals:
    - id: minuet_thermostat_override
      type: bool
      restore_value: true
      initial_value: "false"
    - id: minuet_thermostat_auto_fan_speed
      type: int
      restore_value: false
      initial_value: "0"
    - id: minuet_thermostat_auto_fan_exhaust
      type: bool
      restore_value: false
      initial_value: "true"
    - id: minuet_thermostat_auto_lid_open
      type: bool
      restore_value: false
      initial_value: "false"
    - id: minuet_thermostat_auto_ready
      type: bool
      restore_value: false
      initial_value: "false"
  select:
    - id: minuet_controls
      platform: template
      name: "Controls"
      entity_category: config
      optimistic: true
      restore_value: true
      options:
        - Enhanced
        - Standard
      on_value:
        then:
          - lambda: |-
              if (i == 1) {
                // Reset some settings that can't be changed with the keypad using standard controls
                // although they can still be controlled via the ESPHome API
                id(minuet_thermostat).make_call().set_fan_mode(CLIMATE_FAN_AUTO).perform();
                id(minuet_thermostat_fan_direction).make_call().select_first().perform();
                id(minuet_thermostat_lid_mode).make_call().select_first().perform();
                id(minuet_thermostat_reset_override).execute();
              }
    - id: minuet_thermostat_fan_direction
      platform: template
      name: "Thermostat fan direction"
      entity_category: config
      optimistic: true
      restore_value: true
      options:
        - Default
        - Out
        - In
      on_value:
        then:
          - script.execute: minuet_thermostat_update
    - id: minuet_thermostat_lid_mode
      platform: template
      name: "Thermostat lid mode"
      entity_category: config
      optimistic: true
      restore_value: true
      options:
        - Auto
        - Open
        - Closed
      on_value:
        then:
          - script.execute: minuet_thermostat_update
  climate:
    - id: minuet_thermostat
      name: "Thermostat"
      icon: mdi:thermostat-auto
      platform: thermostat
      sensor: minuet_ambient_temperature # Overridden by the governor package
      visual: # The IR remote uses Fahrenheit natively and expects the fan to do so as well
        min_temperature: ${minuet_thermostat_min_temperature}
        max_temperature: ${minuet_thermostat_max_temperature}
        temperature_step: ${minuet_thermostat_visual_temperature_step}
      cool_overrun: 1Â°C
      cool_deadband: 0.5Â°C
      min_idle_time: 0s
      min_cooling_off_time: 0s
      min_cooling_run_time: 0s
      min_fan_mode_switching_time: 0s
      idle_action:
        then:
          - script.execute: minuet_thermostat_update
      cool_action:
        then:
          - script.execute: minuet_thermostat_update
      fan_mode_off_action:
        then:
          - script.execute: minuet_thermostat_update
      fan_mode_low_action:
        then:
          - script.execute: minuet_thermostat_update
      fan_mode_quiet_action:
        then:
          - script.execute: minuet_thermostat_update
      fan_mode_auto_action:
        then:
          - script.execute: minuet_thermostat_update
      off_mode:
        then:
          - lambda: |-
              id(minuet_thermostat_reset_override).execute();
              if (!minuet::is_transient_operation()) {
                // When the user turns off the thermostat, turn the fan off but restore its
                // last commanded speed and direction.
                const auto& state = minuet::persistent_state();
                id(minuet_fan_set).execute(false, state.fan_speed, state.fan_exhaust,
                      /*suppress_lid_movement*/ false, /*force*/ false);
              }
      on_state:
        then:
          - script.execute: minuet_thermostat_update
      preset: # Note: Additional presets are configured in callbacks
        - name: "Off"
          mode: "off"
          fan_mode: "auto"
          default_target_temperature_high: ${minuet_thermostat_reset_temperature}
      preset_change:
        then:
          - lambda: |-
              const auto& therm = id(minuet_thermostat);
              auto& lid_mode = id(minuet_thermostat_lid_mode);
              lid_mode->make_call().set_index(size_t(minuet::get_thermostat_preset_lid_mode(
                  therm->preset.value_or(ClimatePreset::CLIMATE_PRESET_NONE)))).perform();
      default_preset: 'Off'
      on_boot_restore_from: memory
  switch:
    - id: minuet_thermostat_override_switch
      name: "Thermostat manual override"
      icon: mdi:thermostat
      platform: template
      restore_mode: DISABLED
      lambda: 'return id(minuet_thermostat_override);'
      turn_on_action:
        then:
          - script.execute: minuet_thermostat_maybe_set_override
      turn_off_action:
        then:
          - script.execute: minuet_thermostat_reset_override
  script:
    - id: minuet_thermostat_reconcile_fan_manual_state_change
      parameters:
        fan_state: bool
        fan_speed: int
        fan_exhaust: bool
      then:
        - lambda: |-
            const auto& therm = id(minuet_thermostat);
            if (id(minuet_thermostat_auto_fan_speed) != (fan_state ? fan_speed : 0)
                || (id(minuet_thermostat_auto_fan_exhaust) != fan_exhaust
                    && id(minuet_thermostat_fan_direction).active_index() != 0)) {
              id(minuet_thermostat_maybe_set_override).execute();
            }
    - id: minuet_thermostat_reconcile_lid_manual_state_change
      parameters:
        lid_open: bool
      then:
        - lambda: |-
            const auto& therm = id(minuet_thermostat);
            if (id(minuet_thermostat_auto_lid_open) != lid_open) {
              id(minuet_thermostat_maybe_set_override).execute();
            }
    - id: minuet_thermostat_maybe_set_override
      then:
        - lambda: |-
            // Safety lock check: Do not set thermostat override during safety lock
            if (id(minuet_thermostat).mode != CLIMATE_MODE_OFF && !id(minuet_thermostat_override) && !id(minuet_safety_lock).state) {
              if (id(minuet_controls).active_index() == 0 /*Enhanced*/) {
                // With enhanced controls, activate override mode
                ESP_LOGD(minuet::TAG, "Manual state change while thermostat enabled: engaging override");
                id(minuet_snapshot_fan_persistent_state).execute();
                id(minuet_snapshot_lid_persistent_state).execute();
                id(minuet_thermostat_override) = true;
                id(minuet_thermostat_update).execute();
              } else {
                // With standard controls, override mode isn't supported so turn off the thermostat
                // and leave the fan running in whatever state the user just tried to set it to
                // which is similar to how overriding behaves
                ESP_LOGD(minuet::TAG, "Manual state change while thermostat enabled: disabling thermostat");
                minuet::perform_transient_operation([] {
                  id(minuet_thermostat).make_call().set_mode(CLIMATE_MODE_OFF).perform();
                });
              }
            }
    - id: minuet_thermostat_reset_override
      then:
        - lambda: |-
            id(minuet_thermostat_override) = false;
            id(minuet_thermostat_update).execute();
    - id: minuet_thermostat_update
      then:
        - lambda: |-
            const auto& therm = id(minuet_thermostat);
            auto& auto_ready = id(minuet_thermostat_auto_ready);
            auto& poll = id(minuet_thermostat_poll);
            if (therm->mode != CLIMATE_MODE_OFF && !id(minuet_thermostat_override) && !id(minuet_safety_lock).state) {
              if (!auto_ready) {
                minuet::governor::reset();
                poll->start_poller();
                auto_ready = true;
              }
              minuet::governor::ControlInput input = {
                .ambient_temperature = therm->current_temperature,
                .target_temperature = therm->target_temperature,
                .action = therm->action,
                .fan_mode = therm->fan_mode.value_or(CLIMATE_FAN_AUTO),
                .lid_mode = minuet::LidMode(id(minuet_thermostat_lid_mode).active_index().value_or(0)),
              };
              minuet::governor::ControlOutput output = minuet::governor::update(input);

              auto& auto_fan_speed = id(minuet_thermostat_auto_fan_speed);
              auto_fan_speed = std::clamp(output.fan_speed, 0, 10);

              auto& auto_lid_open = id(minuet_thermostat_auto_lid_open);
              auto_lid_open = output.lid_open;

              const auto& state = minuet::persistent_state();
              const auto& direction_index = id(minuet_thermostat_fan_direction).active_index();
              auto& auto_fan_exhaust = id(minuet_thermostat_auto_fan_exhaust);
              auto_fan_exhaust = direction_index == 1 ? true :
                  direction_index == 2 ? false : state.fan_exhaust;

              minuet::perform_transient_operation([=] {
                id(minuet_fan_set).execute(
                    auto_fan_speed != 0,
                    auto_fan_speed != 0 ? auto_fan_speed : state.fan_speed,
                    auto_fan_speed != 0 ? auto_fan_exhaust : state.fan_exhaust,
                    /*suppress_lid_movement*/ true, /*force*/ false);
                id(minuet_lid_set).execute(auto_lid_open, /*force*/ false);
              });
            } else {
              auto_ready = false;
              poll->stop_poller();
            }
  interval:
    - id: minuet_thermostat_poll
      interval: 1s
      setup_priority: 400
      then:
        lambda: |-
          id(minuet_thermostat_update).execute();


### PACKAGE: THERMOSTAT PRESETS
#
# Creates entities to let the user configure the presets at runtime.
minuet_thermostat_preset_home: !include
  file: thermostat_preset.yaml
  vars:
    minuet_thermostat_preset_id: home
    minuet_thermostat_preset_name: "Home"
    minuet_thermostat_preset_default_temperature: "77Â°F" # exactly 25Â°C
    minuet_thermostat_preset_default_fan_mode: "Auto"
    minuet_thermostat_preset_default_lid_mode: "Auto"
minuet_thermostat_preset_sleep: !include
  file: thermostat_preset.yaml
  vars:
    minuet_thermostat_preset_id: sleep
    minuet_thermostat_preset_name: "Sleep"
    minuet_thermostat_preset_default_temperature: "77Â°F" # exactly 25Â°C
    minuet_thermostat_preset_default_fan_mode: "Quiet"
    minuet_thermostat_preset_default_lid_mode: "Open"
minuet_thermostat_preset_away: !include
  file: thermostat_preset.yaml
  vars:
    minuet_thermostat_preset_id: away
    minuet_thermostat_preset_name: "Away"
    minuet_thermostat_preset_default_temperature: "86Â°F" # exactly 30Â°C
    minuet_thermostat_preset_default_fan_mode: "Low"
    minuet_thermostat_preset_default_lid_mode: "Auto"
minuet_thermostat_preset_eco: !include
  file: thermostat_preset.yaml
  vars:
    minuet_thermostat_preset_id: eco
    minuet_thermostat_preset_name: "Eco"
    minuet_thermostat_preset_default_temperature: "86Â°F" # exactly 30Â°C
    minuet_thermostat_preset_default_fan_mode: "Off"
    minuet_thermostat_preset_default_lid_mode: "Auto"


### PACKAGE: GOVERNOR
#
# Configures the governor module in `governor.h`.
minuet_governor:
  esphome:
    on_boot:
      - priority: 2000
        then:
        - lambda: |-
            // Configure the governor
            <% macro assign_from_id(name, value) %>
              <% if value != '' %>
                minuet::governor::${name} = id(${value});
              <% else %>
                minuet::governor::${name} = nullptr;
              <% endif %>
            <% endmacro %>
            ${ assign_from_id('indoor_ambient_temperature_sensor', minuet_indoor_ambient_temperature_sensor_id) }
            ${ assign_from_id('indoor_relative_humidity_sensor', minuet_indoor_relative_humidity_sensor_id) }
            ${ assign_from_id('indoor_co2_sensor', minuet_indoor_co2_sensor_id) }
            ${ assign_from_id('indoor_aqi_sensor', minuet_indoor_aqi_sensor_id) }
            ${ assign_from_id('outdoor_ambient_temperature_sensor', minuet_outdoor_ambient_temperature_sensor_id) }
            ${ assign_from_id('outdoor_relative_humidity_sensor', minuet_outdoor_relative_humidity_sensor_id) }
            ${ assign_from_id('outdoor_aqi_sensor', minuet_outdoor_aqi_sensor_id) }

            // Use the same sensors for the thermostat
            if (minuet::governor::indoor_ambient_temperature_sensor) {
              id(minuet_thermostat).set_sensor(minuet::governor::indoor_ambient_temperature_sensor);
            }
            if (minuet::governor::indoor_relative_humidity_sensor) {
              id(minuet_thermostat).set_humidity_sensor(minuet::governor::indoor_relative_humidity_sensor);
            }

### PACKAGE: PERSISTENCE
#
# Remembers the fan speed, direction, and lid state that the user most recently
# commanded so that it can be restored when the fan is turned back on or after a restart.
# Transient operations (internal state changes not initiated by the user) do not alter
# the persistent state.
minuet_persistence:
  globals:
    - id: minuet_persistent_state_raw
      type: uint8_t # actually holds minuet::PersistentState
      restore_value: true
      initial_value: "minuet::PersistentState{}.to_storage()"
  select:
    - id: minuet_power_on_behavior
      platform: template
      name: "Power on behavior"
      entity_category: config
      optimistic: true
      restore_value: true
      options:
        - "Off"
        - "Restore"
  script:
    - id: minuet_snapshot_fan_persistent_state
      then:
        - lambda: |-
            const auto& fan = id(minuet_fan);
            auto& state = minuet::persistent_state();
            state.fan_on = fan->state;
            state.fan_speed = fan->speed;
            state.fan_exhaust = minuet::fan_direction_is_exhaust(fan->direction);
    - id: minuet_snapshot_lid_persistent_state
      then:
        - lambda: |-
            const auto& lid = id(minuet_lid);
            auto& state = minuet::persistent_state();
            state.lid_open = minuet::cover_is_open_or_opening(lid);
  esphome:
    on_boot:
      - priority: 1000
        then:
          - lambda: |-
              // Prevent the thermostat off_mode handler from overwriting the persistent state
              // of the fan prior to restoration on boot
              minuet::transient_operation_depth++;
      - priority: 500
        then:
          - lambda: |-
              minuet::transient_operation_depth--;

              // Revert to defaults if not restoring persistent state
              const auto& behavior = id(minuet_power_on_behavior).active_index();
              if (!behavior.has_value() || behavior == 0) {
                minuet::persistent_state() = minuet::PersistentState{};
                minuet::perform_transient_operation([] {
                  id(minuet_thermostat).make_call().set_mode(CLIMATE_MODE_OFF).perform();
                });
              }

              // Restore persistent state
              minuet::perform_transient_operation([] {
                const auto& state = minuet::persistent_state();
                id(minuet_fan_set).execute(state.fan_on, state.fan_speed, state.fan_exhaust,
                      /*suppress_lid_movement*/ true, /*force*/ true);
                id(minuet_lid_set).execute(state.lid_open, /*force*/ true);
              });

              // Apply thermostat updates
              id(minuet_thermostat_update).execute();

### PACKAGE: SHUTDOWN BEHAVIOR
#
# Turns off the motors before ESPHome restarts, just in case.
minuet_shutdown:
  esphome:
    on_shutdown:
      - priority: 500
        then:
          - lambda: |-
              minuet::fan_driver::controller.shutdown();
              id(minuet_lid_motor_sleep).turn_on();

### PACKAGE: FAILSAFE BEHAVIOR
#
# Restarts the firmware when components have failed.
# Waits a few minutes before restarting to allow time for debugging.
minuet_failsafe:
  binary_sensor:
    - id: minuet_failsafe
      name: "Failsafe"
      device_class: problem
      entity_category: diagnostic
      platform: template
      trigger_on_initial_state: true
      lambda: |-
        return id(minuet_fan_driver).is_failed();
      on_press:
        then:
          - delay: 100ms # Ensure component initialization has finished
          - button.press: minuet_failsafe_restart_after_delay
  button:
    - id: minuet_failsafe_restart_after_delay
      platform: template
      on_press:
        then:
          - logger.log:
              format: "Failsafe restart will be triggered after a delay"
              level: ERROR
          - script.execute:
              id: minuet_tone
              name: "!failsafe_restart"
          - delay: 180s
          - logger.log:
              format: "Failsafe restart happening now"
              level: ERROR
          - script.execute:
              id: minuet_tone
              name: "!failsafe_restart"
          - delay: 2s
          - button.press: minuet_restart
